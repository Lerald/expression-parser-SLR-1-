#include <stdio.h>
#include <stdlib.h>
#include "parser.h"

Parser :: ~Parser(){
	delete stack;
	delete scan;
	return;
}

Parser :: Parser(const unsigned char* t, Error_count* e, Code_buffer* cg){
	scan  = new Scaner(t,e);
	stack = new Parser_stack();
	gen   = cg;
	ec    = e;
	return;
}

#define ANY 200

enum Non_terminal {nt_S, nt_T, nt_E, nt_F, nt_G, nt_H, nt_K, nt_L, nt_M, nt_N};

enum Rule_names {
	S_IS_T_COND_T_COLON_T, 	S_IS_T,
	T_IS_T_NOR_E,			T_IS_T_OR_E,		T_IS_T_XOR_E,	T_IS_E,
	E_IS_E_NAND_F,			E_IS_E_AND_F,		E_IS_F,
	F_IS_NOT_F,				F_IS_G,
	G_IS_G_EQ_H,			G_IS_G_NEQ_H,		G_IS_G_LT_H,	
	G_IS_G_GT_H,			G_IS_G_LEQ_H,		G_IS_G_GEQ_H,
	G_IS_H,
	H_IS_H_PLUS_K,			H_IS_H_MINUS_K,		H_IS_K,
	K_IS_K_MULT_L,			K_IS_K_DIV_L,		K_IS_L,
	L_IS_M_DEGREE_L,		L_IS_M,
	M_IS_PLUS_N,			M_IS_MINUS_N,		M_IS_N,
	N_IS_OB_S_CB,			N_IS_TRUE,			N_IS_FALSE,		N_IS_INT
};

// Таблица действий состоит из пар вида 
// (указатель на таблицу действий для состояния, размер таблицы для состояния)

// Элементы таблицы действий для состояния выглядят так:
// (код лексемы, действие)
// Элементы таблицы действий упорядочены по возрастанию кодов лексем.
// Кроме того, первой компонентой элемента таблицы действий для состояния
// может быть специальное значение ANY, большее любого кода лексемы. Оно означает,
// что если элемента таблицы с нужным кодом лексемы нет, то выполняется действие,
// указанное второй компонентой пары с ANY в качестве кода лексемы.
// Под действие отведём один байт (unsigned char). Этот байт представляет собой 
// битовую структуру со следующими компонентами:
//    бит 15 (is_undefined) --- нужно ли при переносе или свёртке устанавливать признак
//                             неопределённого значения;
//    биты 14--13 (action_code) --- код действия (см. enum Action_names);
//    биты 12--0 (argument) --- номер правила для свёртки при свёртке и номер 
//                             переносимого состояния при переносе.
 
#define ACTION(isdef,actcode,arg) (((isdef) << 15) | ((actcode) << 13) | (arg))

#define DEFINED_VALUE   0
#define UNDEFINED_VALUE 1

struct Entry_of_action_table_for_state {
	unsigned short lexem_code;
	unsigned short action_code;
};

#define ELEMS_IN_TABLE_FOR_STATE(t) (sizeof(t)/sizeof(Entry_of_action_table_for_state))

struct Entry_of_action_table {
	Entry_of_action_table_for_state* ptr_to_action_table_for_state;
	size_t							 number_of_actions;
};

static inline Action_info unpack_action_code(unsigned int a){
	Action_info ainfo;
	
	ainfo.is_undefined = a >> 15;
	ainfo.argument   = a & 0x1fff;
	ainfo.action     = static_cast<Action_names>((a >> 13) & 3);
	
	return ainfo;
}

static Entry_of_action_table_for_state actions_for_state_0[] = {	
	{NOT,				ACTION(DEFINED_VALUE,	act_SHIFT,  11)},
	{PLUS,				ACTION(DEFINED_VALUE,	act_SHIFT,	12)},
	{MINUS,				ACTION(DEFINED_VALUE,	act_SHIFT,	13)},
	{OPENED_BRACKET, 	ACTION(DEFINED_VALUE,	act_SHIFT,	14)},
	{kw_ISTINA,			ACTION(DEFINED_VALUE,	act_SHIFT,	15)}, 
	{kw_LOZH,			ACTION(DEFINED_VALUE,	act_SHIFT,	16)},
	{t_INT,				ACTION(DEFINED_VALUE,	act_SHIFT,	17)},
	{ANY, 				ACTION(UNDEFINED_VALUE,	act_SHIFT,	11)} 
};

static Entry_of_action_table_for_state actions_for_state_1[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_OK,		0 )}
};

static Entry_of_action_table_for_state actions_for_state_2[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	S_IS_T)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_SHIFT,	18)}, 
	{NOR, 				ACTION(DEFINED_VALUE,	act_SHIFT,	19)},
	{OR, 				ACTION(DEFINED_VALUE,	act_SHIFT,	20)},
	{XOR,				ACTION(DEFINED_VALUE,	act_SHIFT,	21)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, S_IS_T)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, S_IS_T)} 
};

static Entry_of_action_table_for_state actions_for_state_3[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	T_IS_E)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	T_IS_E)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	T_IS_E)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	T_IS_E)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	T_IS_E)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	T_IS_E)},
	{NAND,				ACTION(DEFINED_VALUE,	act_SHIFT,	22)},
	{AND,				ACTION(DEFINED_VALUE,	act_SHIFT,	23)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, T_IS_E)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, T_IS_E)} 
};

static Entry_of_action_table_for_state actions_for_state_4[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	E_IS_F)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	E_IS_F)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	E_IS_F)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	E_IS_F)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	E_IS_F)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	E_IS_F)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	E_IS_F)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	E_IS_F)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, E_IS_F)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, E_IS_F)} 
};

static Entry_of_action_table_for_state actions_for_state_5[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	F_IS_G)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	F_IS_G)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	F_IS_G)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	F_IS_G)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	F_IS_G)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	F_IS_G)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	F_IS_G)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	F_IS_G)},
	{EQ,				ACTION(DEFINED_VALUE,	act_SHIFT,	24)},
	{NEQ,				ACTION(DEFINED_VALUE,	act_SHIFT,	25)},
	{LT,				ACTION(DEFINED_VALUE,	act_SHIFT,	26)},
	{GT,				ACTION(DEFINED_VALUE,	act_SHIFT,	27)},
	{LEQ,				ACTION(DEFINED_VALUE,	act_SHIFT,	28)},
	{GEQ,				ACTION(DEFINED_VALUE,	act_SHIFT,	29)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, F_IS_G)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, F_IS_G)} 
};

static Entry_of_action_table_for_state actions_for_state_6[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_H)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_H)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_H)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_H)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_H)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_H)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_H)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_H)},
	{EQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_H)},
	{NEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_H)},
	{LT,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_H)},
	{GT,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_H)},
	{LEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_H)},
	{GEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_H)},
	{PLUS,				ACTION(DEFINED_VALUE,	act_SHIFT,	30)},
	{MINUS,				ACTION(DEFINED_VALUE,	act_SHIFT,	31)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, G_IS_H)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, G_IS_H)} 
};

static Entry_of_action_table_for_state actions_for_state_7[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_K)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_K)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_K)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_K)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_K)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_K)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_K)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_K)},
	{EQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_K)},
	{NEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_K)},
	{LT,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_K)},
	{GT,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_K)},
	{LEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_K)},
	{GEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_K)},
	{PLUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_K)},
	{MINUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_K)},
	{MULT,				ACTION(DEFINED_VALUE,	act_SHIFT,	32)},
	{DIV,				ACTION(DEFINED_VALUE,	act_SHIFT,	33)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, H_IS_K)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, H_IS_K)} 
};

static Entry_of_action_table_for_state actions_for_state_8[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_L)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_L)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_L)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_L)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_L)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_L)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_L)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_L)},
	{EQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_L)},
	{NEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_L)},
	{LT,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_L)},
	{GT,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_L)},
	{LEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_L)},
	{GEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_L)},
	{PLUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_L)},
	{MINUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_L)},
	{MULT,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_L)},
	{DIV,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_L)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, K_IS_L)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, K_IS_L)} 
};

static Entry_of_action_table_for_state actions_for_state_9[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M)},
	{EQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M)},
	{NEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M)},
	{LT,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M)},
	{GT,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M)},
	{LEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M)},
	{GEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M)},
	{PLUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M)},
	{MINUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M)},
	{MULT,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M)},
	{DIV,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M)},
	{DEGREE,			ACTION(DEFINED_VALUE,	act_SHIFT,	34)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, L_IS_M)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, L_IS_M)} 
};

static Entry_of_action_table_for_state actions_for_state_10[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_N)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_N)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_N)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_N)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_N)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_N)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_N)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_N)},
	{EQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_N)},
	{NEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_N)},
	{LT,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_N)},
	{GT,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_N)},
	{LEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_N)},
	{GEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_N)},
	{PLUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_N)},
	{MINUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_N)},
	{MULT,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_N)},
	{DIV,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_N)},
	{DEGREE,			ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_N)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, M_IS_N)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, M_IS_N)} 
};

static Entry_of_action_table_for_state actions_for_state_12[] = {	
	{OPENED_BRACKET, 	ACTION(DEFINED_VALUE,	act_SHIFT,	14)},
	{kw_ISTINA,			ACTION(DEFINED_VALUE,	act_SHIFT,	15)}, 
	{kw_LOZH,			ACTION(DEFINED_VALUE,	act_SHIFT,	16)},
	{t_INT,				ACTION(DEFINED_VALUE,	act_SHIFT,	17)},
	{ANY, 				ACTION(UNDEFINED_VALUE,	act_SHIFT,	14)} 
};

static Entry_of_action_table_for_state actions_for_state_15[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_TRUE)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_TRUE)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_TRUE)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_TRUE)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_TRUE)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_TRUE)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_TRUE)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_TRUE)},
	{EQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_TRUE)},
	{NEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_TRUE)},
	{LT,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_TRUE)},
	{GT,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_TRUE)},
	{LEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_TRUE)},
	{GEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_TRUE)},
	{PLUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_TRUE)},
	{MINUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_TRUE)},
	{MULT,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_TRUE)},
	{DIV,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_TRUE)},
	{DEGREE,			ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_TRUE)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, N_IS_TRUE)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, N_IS_TRUE)} 
};

static Entry_of_action_table_for_state actions_for_state_16[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_FALSE)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_FALSE)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_FALSE)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_FALSE)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_FALSE)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_FALSE)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_FALSE)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_FALSE)},
	{EQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_FALSE)},
	{NEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_FALSE)},
	{LT,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_FALSE)},
	{GT,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_FALSE)},
	{LEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_FALSE)},
	{GEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_FALSE)},
	{PLUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_FALSE)},
	{MINUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_FALSE)},
	{MULT,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_FALSE)},
	{DIV,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_FALSE)},
	{DEGREE,			ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_FALSE)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, N_IS_FALSE)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, N_IS_FALSE)} 
};

static Entry_of_action_table_for_state actions_for_state_17[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_INT)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_INT)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_INT)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_INT)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_INT)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_INT)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_INT)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_INT)},
	{EQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_INT)},
	{NEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_INT)},
	{LT,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_INT)},
	{GT,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_INT)},
	{LEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_INT)},
	{GEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_INT)},
	{PLUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_INT)},
	{MINUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_INT)},
	{MULT,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_INT)},
	{DIV,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_INT)},
	{DEGREE,			ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_INT)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, N_IS_INT)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, N_IS_INT)} 
};

static Entry_of_action_table_for_state actions_for_state_24[] = {	
	{PLUS,				ACTION(DEFINED_VALUE,	act_SHIFT,	12)},
	{MINUS,				ACTION(DEFINED_VALUE,	act_SHIFT,	13)},
	{OPENED_BRACKET, 	ACTION(DEFINED_VALUE,	act_SHIFT,	14)},
	{kw_ISTINA,			ACTION(DEFINED_VALUE,	act_SHIFT,	15)}, 
	{kw_LOZH,			ACTION(DEFINED_VALUE,	act_SHIFT,	16)},
	{t_INT,				ACTION(DEFINED_VALUE,	act_SHIFT,	17)},
	{ANY, 				ACTION(UNDEFINED_VALUE,	act_SHIFT,	12)} 
};

static Entry_of_action_table_for_state actions_for_state_35[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	F_IS_NOT_F)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	F_IS_NOT_F)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	F_IS_NOT_F)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	F_IS_NOT_F)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	F_IS_NOT_F)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	F_IS_NOT_F)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	F_IS_NOT_F)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	F_IS_NOT_F)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, F_IS_NOT_F)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, F_IS_NOT_F)}
};

static Entry_of_action_table_for_state actions_for_state_36[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_PLUS_N)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_PLUS_N)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_PLUS_N)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_PLUS_N)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_PLUS_N)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_PLUS_N)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_PLUS_N)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_PLUS_N)},
	{EQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_PLUS_N)},
	{NEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_PLUS_N)},
	{LT,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_PLUS_N)},
	{GT,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_PLUS_N)},
	{LEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_PLUS_N)},
	{GEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_PLUS_N)},
	{PLUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_PLUS_N)},
	{MINUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_PLUS_N)},
	{MULT,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_PLUS_N)},
	{DIV,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_PLUS_N)},
	{DEGREE,			ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_PLUS_N)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, M_IS_PLUS_N)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, M_IS_PLUS_N)} 
};

static Entry_of_action_table_for_state actions_for_state_37[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_MINUS_N)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_MINUS_N)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_MINUS_N)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_MINUS_N)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_MINUS_N)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_MINUS_N)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_MINUS_N)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_MINUS_N)},
	{EQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_MINUS_N)},
	{NEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_MINUS_N)},
	{LT,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_MINUS_N)},
	{GT,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_MINUS_N)},
	{LEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_MINUS_N)},
	{GEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_MINUS_N)},
	{PLUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_MINUS_N)},
	{MINUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_MINUS_N)},
	{MULT,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_MINUS_N)},
	{DIV,				ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_MINUS_N)},
	{DEGREE,			ACTION(DEFINED_VALUE,	act_REDUCE,	M_IS_MINUS_N)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, M_IS_MINUS_N)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, M_IS_MINUS_N)} 
};

static Entry_of_action_table_for_state actions_for_state_38[] = {
	{CLOSED_BRACKET, 	ACTION(DEFINED_VALUE,	act_SHIFT,	56)},
	{ANY,				ACTION(UNDEFINED_VALUE,	act_SHIFT,	56)} 
};

static Entry_of_action_table_for_state actions_for_state_39[] = {
	{COLON,				ACTION(DEFINED_VALUE,	act_SHIFT,	57)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_SHIFT,	19)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_SHIFT,	20)},
	{XOR,				ACTION(DEFINED_VALUE,	act_SHIFT,	21)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_SHIFT,	57)} 
};

static Entry_of_action_table_for_state actions_for_state_40[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	T_IS_T_NOR_E)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	T_IS_T_NOR_E)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	T_IS_T_NOR_E)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	T_IS_T_NOR_E)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	T_IS_T_NOR_E)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	T_IS_T_NOR_E)},
	{NAND,				ACTION(DEFINED_VALUE,	act_SHIFT,	22)},
	{AND,				ACTION(DEFINED_VALUE,	act_SHIFT,	23)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, T_IS_T_NOR_E)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, T_IS_T_NOR_E)} 
};

static Entry_of_action_table_for_state actions_for_state_41[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	T_IS_T_OR_E)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	T_IS_T_OR_E)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	T_IS_T_OR_E)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	T_IS_T_OR_E)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	T_IS_T_OR_E)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	T_IS_T_OR_E)},
	{NAND,				ACTION(DEFINED_VALUE,	act_SHIFT,	22)},
	{AND,				ACTION(DEFINED_VALUE,	act_SHIFT,	23)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, T_IS_T_OR_E)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, T_IS_T_OR_E)} 
};

static Entry_of_action_table_for_state actions_for_state_42[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	T_IS_T_XOR_E)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	T_IS_T_XOR_E)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	T_IS_T_XOR_E)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	T_IS_T_XOR_E)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	T_IS_T_XOR_E)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	T_IS_T_XOR_E)},
	{NAND,				ACTION(DEFINED_VALUE,	act_SHIFT,	22)},
	{AND,				ACTION(DEFINED_VALUE,	act_SHIFT,	23)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, T_IS_T_XOR_E)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, T_IS_T_XOR_E)} 
};

static Entry_of_action_table_for_state actions_for_state_43[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	E_IS_E_NAND_F)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	E_IS_E_NAND_F)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	E_IS_E_NAND_F)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	E_IS_E_NAND_F)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	E_IS_E_NAND_F)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	E_IS_E_NAND_F)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	E_IS_E_NAND_F)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	E_IS_E_NAND_F)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, E_IS_E_NAND_F)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, E_IS_E_NAND_F)}
};

static Entry_of_action_table_for_state actions_for_state_44[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	E_IS_E_AND_F)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	E_IS_E_AND_F)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	E_IS_E_AND_F)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	E_IS_E_AND_F)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	E_IS_E_AND_F)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	E_IS_E_AND_F)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	E_IS_E_AND_F)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	E_IS_E_AND_F)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, E_IS_E_AND_F)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, E_IS_E_AND_F)}
};

static Entry_of_action_table_for_state actions_for_state_45[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_EQ_H)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_EQ_H)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_EQ_H)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_EQ_H)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_EQ_H)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_EQ_H)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_EQ_H)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_EQ_H)},
	{EQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_EQ_H)},
	{NEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_EQ_H)},
	{LT,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_EQ_H)},
	{GT,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_EQ_H)},
	{LEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_EQ_H)},
	{GEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_EQ_H)},
	{PLUS,				ACTION(DEFINED_VALUE,	act_SHIFT,	30)},
	{MINUS,				ACTION(DEFINED_VALUE,	act_SHIFT,	31)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, G_IS_G_EQ_H)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, G_IS_G_EQ_H)} 
};

static Entry_of_action_table_for_state actions_for_state_46[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_NEQ_H)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_NEQ_H)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_NEQ_H)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_NEQ_H)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_NEQ_H)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_NEQ_H)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_NEQ_H)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_NEQ_H)},
	{EQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_NEQ_H)},
	{NEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_NEQ_H)},
	{LT,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_NEQ_H)},
	{GT,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_NEQ_H)},
	{LEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_NEQ_H)},
	{GEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_NEQ_H)},
	{PLUS,				ACTION(DEFINED_VALUE,	act_SHIFT,	30)},
	{MINUS,				ACTION(DEFINED_VALUE,	act_SHIFT,	31)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, G_IS_G_NEQ_H)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, G_IS_G_NEQ_H)} 
};

static Entry_of_action_table_for_state actions_for_state_47[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LT_H)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LT_H)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LT_H)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LT_H)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LT_H)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LT_H)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LT_H)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LT_H)},
	{EQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LT_H)},
	{NEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LT_H)},
	{LT,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LT_H)},
	{GT,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LT_H)},
	{LEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LT_H)},
	{GEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LT_H)},
	{PLUS,				ACTION(DEFINED_VALUE,	act_SHIFT,	30)},
	{MINUS,				ACTION(DEFINED_VALUE,	act_SHIFT,	31)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, G_IS_G_LT_H)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, G_IS_G_LT_H)} 
};

static Entry_of_action_table_for_state actions_for_state_48[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GT_H)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GT_H)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GT_H)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GT_H)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GT_H)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GT_H)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GT_H)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GT_H)},
	{EQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GT_H)},
	{NEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GT_H)},
	{LT,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GT_H)},
	{GT,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GT_H)},
	{LEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GT_H)},
	{GEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GT_H)},
	{PLUS,				ACTION(DEFINED_VALUE,	act_SHIFT,	30)},
	{MINUS,				ACTION(DEFINED_VALUE,	act_SHIFT,	31)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, G_IS_G_GT_H)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, G_IS_G_GT_H)} 
};

static Entry_of_action_table_for_state actions_for_state_49[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LEQ_H)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LEQ_H)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LEQ_H)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LEQ_H)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LEQ_H)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LEQ_H)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LEQ_H)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LEQ_H)},
	{EQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LEQ_H)},
	{NEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LEQ_H)},
	{LT,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LEQ_H)},
	{GT,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LEQ_H)},
	{LEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LEQ_H)},
	{GEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_LEQ_H)},
	{PLUS,				ACTION(DEFINED_VALUE,	act_SHIFT,	30)},
	{MINUS,				ACTION(DEFINED_VALUE,	act_SHIFT,	31)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, G_IS_G_LEQ_H)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, G_IS_G_LEQ_H)} 
};

static Entry_of_action_table_for_state actions_for_state_50[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GEQ_H)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GEQ_H)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GEQ_H)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GEQ_H)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GEQ_H)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GEQ_H)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GEQ_H)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GEQ_H)},
	{EQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GEQ_H)},
	{NEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GEQ_H)},
	{LT,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GEQ_H)},
	{GT,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GEQ_H)},
	{LEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GEQ_H)},
	{GEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	G_IS_G_GEQ_H)},
	{PLUS,				ACTION(DEFINED_VALUE,	act_SHIFT,	30)},
	{MINUS,				ACTION(DEFINED_VALUE,	act_SHIFT,	31)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, G_IS_G_GEQ_H)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, G_IS_G_GEQ_H)} 
};

static Entry_of_action_table_for_state actions_for_state_51[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_PLUS_K)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_PLUS_K)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_PLUS_K)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_PLUS_K)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_PLUS_K)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_PLUS_K)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_PLUS_K)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_PLUS_K)},
	{EQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_PLUS_K)},
	{NEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_PLUS_K)},
	{LT,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_PLUS_K)},
	{GT,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_PLUS_K)},
	{LEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_PLUS_K)},
	{GEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_PLUS_K)},
	{PLUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_PLUS_K)},
	{MINUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_PLUS_K)},
	{MULT,				ACTION(DEFINED_VALUE,	act_SHIFT,	32)},
	{DIV,				ACTION(DEFINED_VALUE,	act_SHIFT,	33)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, H_IS_H_PLUS_K)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, H_IS_H_PLUS_K)} 
};

static Entry_of_action_table_for_state actions_for_state_52[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_MINUS_K)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_MINUS_K)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_MINUS_K)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_MINUS_K)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_MINUS_K)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_MINUS_K)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_MINUS_K)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_MINUS_K)},
	{EQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_MINUS_K)},
	{NEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_MINUS_K)},
	{LT,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_MINUS_K)},
	{GT,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_MINUS_K)},
	{LEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_MINUS_K)},
	{GEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_MINUS_K)},
	{PLUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_MINUS_K)},
	{MINUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	H_IS_H_MINUS_K)},
	{MULT,				ACTION(DEFINED_VALUE,	act_SHIFT,	32)},
	{DIV,				ACTION(DEFINED_VALUE,	act_SHIFT,	33)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, H_IS_H_MINUS_K)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, H_IS_H_MINUS_K)} 
};

static Entry_of_action_table_for_state actions_for_state_53[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_MULT_L)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_MULT_L)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_MULT_L)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_MULT_L)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_MULT_L)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_MULT_L)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_MULT_L)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_MULT_L)},
	{EQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_MULT_L)},
	{NEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_MULT_L)},
	{LT,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_MULT_L)},
	{GT,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_MULT_L)},
	{LEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_MULT_L)},
	{GEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_MULT_L)},
	{PLUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_MULT_L)},
	{MINUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_MULT_L)},
	{MULT,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_MULT_L)},
	{DIV,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_MULT_L)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, K_IS_K_MULT_L)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, K_IS_K_MULT_L)} 
};

static Entry_of_action_table_for_state actions_for_state_54[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_DIV_L)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_DIV_L)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_DIV_L)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_DIV_L)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_DIV_L)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_DIV_L)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_DIV_L)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_DIV_L)},
	{EQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_DIV_L)},
	{NEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_DIV_L)},
	{LT,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_DIV_L)},
	{GT,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_DIV_L)},
	{LEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_DIV_L)},
	{GEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_DIV_L)},
	{PLUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_DIV_L)},
	{MINUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_DIV_L)},
	{MULT,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_DIV_L)},
	{DIV,				ACTION(DEFINED_VALUE,	act_REDUCE,	K_IS_K_DIV_L)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, K_IS_K_DIV_L)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, K_IS_K_DIV_L)} 
};

static Entry_of_action_table_for_state actions_for_state_55[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M_DEGREE_L)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M_DEGREE_L)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M_DEGREE_L)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M_DEGREE_L)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M_DEGREE_L)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M_DEGREE_L)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M_DEGREE_L)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M_DEGREE_L)},
	{EQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M_DEGREE_L)},
	{NEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M_DEGREE_L)},
	{LT,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M_DEGREE_L)},
	{GT,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M_DEGREE_L)},
	{LEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M_DEGREE_L)},
	{GEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M_DEGREE_L)},
	{PLUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M_DEGREE_L)},
	{MINUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M_DEGREE_L)},
	{MULT,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M_DEGREE_L)},
	{DIV,				ACTION(DEFINED_VALUE,	act_REDUCE,	L_IS_M_DEGREE_L)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, L_IS_M_DEGREE_L)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, L_IS_M_DEGREE_L)} 
};

static Entry_of_action_table_for_state actions_for_state_56[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_OB_S_CB)},
	{CONDITION,			ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_OB_S_CB)}, 
	{COLON,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_OB_S_CB)}, 
	{NOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_OB_S_CB)}, 
	{OR,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_OB_S_CB)},
	{XOR,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_OB_S_CB)},
	{NAND,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_OB_S_CB)},
	{AND,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_OB_S_CB)},
	{EQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_OB_S_CB)},
	{NEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_OB_S_CB)},
	{LT,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_OB_S_CB)},
	{GT,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_OB_S_CB)},
	{LEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_OB_S_CB)},
	{GEQ,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_OB_S_CB)},
	{PLUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_OB_S_CB)},
	{MINUS,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_OB_S_CB)},
	{MULT,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_OB_S_CB)},
	{DIV,				ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_OB_S_CB)},
	{DEGREE,			ACTION(DEFINED_VALUE,	act_REDUCE,	N_IS_OB_S_CB)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, N_IS_OB_S_CB)},
	{ANY,				ACTION(UNDEFINED_VALUE, act_REDUCE, N_IS_OB_S_CB)} 
};

static Entry_of_action_table_for_state actions_for_state_58[] = {
	{NONE,				ACTION(DEFINED_VALUE,	act_REDUCE,	S_IS_T_COND_T_COLON_T)},
	{NOR, 				ACTION(DEFINED_VALUE,	act_SHIFT,	19)},
	{OR, 				ACTION(DEFINED_VALUE,	act_SHIFT,	20)},
	{XOR,				ACTION(DEFINED_VALUE,	act_SHIFT,	21)},
	{CLOSED_BRACKET,	ACTION(DEFINED_VALUE, 	act_REDUCE, S_IS_T_COND_T_COLON_T)},
	{ANY,				ACTION(UNDEFINED_VALUE,	act_REDUCE,	S_IS_T_COND_T_COLON_T)} 
};


static const Entry_of_action_table action_table[] = {
	{actions_for_state_0,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_0 )},	// состояние 0
	{actions_for_state_1,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_1 )},	// состояние 1
	{actions_for_state_2,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_2 )},	// состояние 2
	{actions_for_state_3,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_3 )},	// состояние 3
	{actions_for_state_4,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_4 )},	// состояние 4
	{actions_for_state_5,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_5 )},	// состояние 5
	{actions_for_state_6,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_6 )},	// состояние 6
	{actions_for_state_7,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_7 )},	// состояние 7
	{actions_for_state_8,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_0 )},	// состояние 8
	{actions_for_state_9,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_0 )},	// состояние 9
	
	{actions_for_state_10,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_0 )},	// состояние 10
	{actions_for_state_0,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_0 )},	// состояние 11
	{actions_for_state_12,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_12 )},	// состояние 12
	{actions_for_state_12, 	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_12 )},	// состояние 13
	{actions_for_state_0, 	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_0 )},	// состояние 14
	{actions_for_state_15,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_15 )},	// состояние 15
	{actions_for_state_16,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_16 )},	// состояние 16
	{actions_for_state_17,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_17 )},	// состояние 17
	{actions_for_state_0,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_0 )},	// состояние 18
	{actions_for_state_0, 	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_0 )},	// состояние 19
	{actions_for_state_0, 	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_0 )},	// состояние 20
	
	{actions_for_state_0, 	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_0 )}, 	// состояние 21
	{actions_for_state_0, 	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_0 )},	// состояние 22
	{actions_for_state_0, 	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_0 )},	// состояние 23
	{actions_for_state_24,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_24 )},	// состояние 24
	{actions_for_state_24,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_24 )},	// состояние 25
	{actions_for_state_24,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_24 )},	// состояние 26
	{actions_for_state_24,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_24 )},	// состояние 27
	{actions_for_state_24,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_24 )},	// состояние 28
	{actions_for_state_24,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_24 )},	// состояние 29
	{actions_for_state_24,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_24 )},	// состояние 30
	
	{actions_for_state_24,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_24 )},	// состояние 31
	{actions_for_state_24,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_24 )},	// состояние 32
	{actions_for_state_24,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_24 )},	// состояние 33
	{actions_for_state_24,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_24 )},	// состояние 34
	{actions_for_state_35,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_35 )},	// состояние 35
	{actions_for_state_36, 	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_36)},	// состояние 36
	{actions_for_state_37,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_37)},	// состояние 37
	{actions_for_state_38,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_38)},	// состояние 38
	{actions_for_state_39,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_39)},	// состояние 39
	{actions_for_state_40,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_40)},	// состояние 40
	
	{actions_for_state_41,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_41 )},	// состояние 41
	{actions_for_state_42,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_42 )},	// состояние 42
	{actions_for_state_43,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_42 )},	// состояние 43
	{actions_for_state_44,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_44 )},	// состояние 44
	{actions_for_state_45,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_45 )},	// состояние 45
	{actions_for_state_46, 	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_46)},	// состояние 46
	{actions_for_state_47,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_47)},	// состояние 47
	{actions_for_state_48,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_48)},	// состояние 48
	{actions_for_state_49,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_49)},	// состояние 49
	{actions_for_state_50,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_50)},	// состояние 50
	
	{actions_for_state_51,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_51 )},	// состояние 51
	{actions_for_state_52,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_52 )},	// состояние 52
	{actions_for_state_53,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_53 )},	// состояние 53
	{actions_for_state_54,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_54 )},	// состояние 54
	{actions_for_state_55,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_55 )},	// состояние 55
	{actions_for_state_56, 	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_56)},	// состояние 56
	{actions_for_state_0,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_0)},		// состояние 57
	{actions_for_state_58,	ELEMS_IN_TABLE_FOR_STATE(actions_for_state_58)}		// состояние 58
};

static Action_info search_in_action_table_for_state( Entry_of_action_table t, LEXEM_CODE lc)
{
	Entry_of_action_table_for_state* q = t.ptr_to_action_table_for_state;
	int left = 0;
	int right = t.number_of_actions ;
	int result = t.number_of_actions ;

	while( left <= right )
	{
		int mid = (left + right) / 2;

		if( lc == q[mid].lexem_code)
		{
			result = mid;
			break;
		}
		
		if( lc > q[mid].lexem_code)
		{
			left = mid + 1;
		}
		else if( lc < q[mid].lexem_code)
		{
			right = mid - 1;
		}
	}
	return unpack_action_code( q[result].action_code);
}

static inline Action_info get_action(int number_of_state, LEXEM_CODE lc){
	return search_in_action_table_for_state(action_table[number_of_state], lc);
}

// Таблица ПЕРЕХОД будет состоять из элементов вида
// (указатель на массив записей для нетерминала,количество записей)

// Массив записей для нетерминала будет состоять из элементов вида
// (текущее состояние, следующее состояние)
// При этом в качестве первой компоненты элемента может быть специальное значение ANY, 
// большее любого номера состояния.

struct Entry_for_GOTO_table_for_nonterminal {
	unsigned char current_state;
	unsigned char next_state;
};

struct Entry_of_GOTO_table {
	Entry_for_GOTO_table_for_nonterminal* ptr_to_table_for_nonterminal;
	size_t								  number_of_jumps;
};

#define ELEMS_IN_TABLE_FOR_NONTERMINAL(t) \
	(sizeof(t)/sizeof(Entry_for_GOTO_table_for_nonterminal) - 1)

static Entry_for_GOTO_table_for_nonterminal GOTO_for_S[] = {
	{0, 1}, {ANY, 38}
};

static Entry_for_GOTO_table_for_nonterminal GOTO_for_T[] = {
	{18, 39}, {57, 58}, {ANY, 2}
};

static Entry_for_GOTO_table_for_nonterminal GOTO_for_E[] = {
	{19, 40}, {20, 41}, {21, 42}, {ANY, 3}
};

static Entry_for_GOTO_table_for_nonterminal GOTO_for_F[] = {
	{11, 35}, {22, 43}, {23, 44}, {ANY, 4}
};

static Entry_for_GOTO_table_for_nonterminal GOTO_for_G[] = {
	{ANY, 5}
};

static Entry_for_GOTO_table_for_nonterminal GOTO_for_H[] = {
	{24, 45}, {25, 46}, {26, 47}, {27, 48}, {28, 49}, {29, 50}, {ANY, 6}
};

static Entry_for_GOTO_table_for_nonterminal GOTO_for_K[] = {
	{30, 51}, {31, 52}, {ANY, 7}
};

static Entry_for_GOTO_table_for_nonterminal GOTO_for_L[] = {
	{32, 53}, {33, 54}, {34, 55}, {ANY, 8}
};

static Entry_for_GOTO_table_for_nonterminal GOTO_for_M[] = {
	{ANY, 9}
};

static Entry_for_GOTO_table_for_nonterminal GOTO_for_N[] = {
	{12, 36}, {13, 37}, {ANY, 10}
};

static const Entry_of_GOTO_table GOTO_table[] = {
	{GOTO_for_S, ELEMS_IN_TABLE_FOR_NONTERMINAL(GOTO_for_S)},
	{GOTO_for_T, ELEMS_IN_TABLE_FOR_NONTERMINAL(GOTO_for_T)},
	{GOTO_for_E, ELEMS_IN_TABLE_FOR_NONTERMINAL(GOTO_for_E)},
	{GOTO_for_F, ELEMS_IN_TABLE_FOR_NONTERMINAL(GOTO_for_F)},
	{GOTO_for_G, ELEMS_IN_TABLE_FOR_NONTERMINAL(GOTO_for_G)},
	{GOTO_for_H, ELEMS_IN_TABLE_FOR_NONTERMINAL(GOTO_for_H)},
	{GOTO_for_K, ELEMS_IN_TABLE_FOR_NONTERMINAL(GOTO_for_K)},
	{GOTO_for_L, ELEMS_IN_TABLE_FOR_NONTERMINAL(GOTO_for_L)},
	{GOTO_for_M, ELEMS_IN_TABLE_FOR_NONTERMINAL(GOTO_for_M)},
	{GOTO_for_N, ELEMS_IN_TABLE_FOR_NONTERMINAL(GOTO_for_N)}
};

static int search_in_goto_table_for_nonterminal(Entry_of_GOTO_table t, unsigned char s){
	int i = 0;
	Entry_for_GOTO_table_for_nonterminal* q = t.ptr_to_table_for_nonterminal;
	while(s > q[i].current_state){
		i++;
	}
	return (q[i].current_state == s) ? q[i].next_state : q[t.number_of_jumps].next_state;
}

static inline int get_next_state(Non_terminal nt, unsigned char current_state){
	return search_in_goto_table_for_nonterminal(GOTO_table[nt], current_state);
}

void Parser::diagnostic_for_shift( unsigned state)
{
	switch(state)
	{
	case 11:
		{
			printf("В строке %d ожидается что-либо из следующего: %s.\n",
		       scan->get_line_number(), "!, +, -, (, истина, ложь, целое");
		    break;
		}
		
	case 12:
		{
			printf("В строке %d ожидается что-либо из следующего: %s.\n",
		       scan->get_line_number(), "+, -, (, истина, ложь, целое");
		    break;
		}
		
	case 14:
		{
			printf("В строке %d ожидается что-либо из следующего: %s.\n",
		       scan->get_line_number(), "(, истина, ложь, целое");
		    break;
		}
		
	case 56:
		{
			printf("В строке %d ожидается: ).\n",
		       scan->get_line_number());
		    break;
		}
		
	case 57:
		{
			printf("В строке %d ожидается что-либо из следующего: %s.\n",
		       scan->get_line_number(), ":, !||, ||, ^^");
		    break;
		}      
	}
			
	ec->increment_number_of_errors();
	return;
}

struct Rule_info {
	char non_terminal;
	char length;
};

Rule_info rules[] = {
	{nt_S, 5}, {nt_S, 1}, 
	{nt_T, 3}, {nt_T, 3}, {nt_T, 3}, {nt_T, 1},
	{nt_E, 3}, {nt_E, 3}, {nt_E, 1}, 
	{nt_F, 2}, {nt_F, 1}, 
	{nt_G, 3}, {nt_G, 3}, {nt_G, 3}, {nt_G, 3}, {nt_G, 3}, {nt_G, 3}, {nt_G, 1},
	{nt_H, 3}, {nt_H, 3}, {nt_H, 1},
	{nt_K, 3}, {nt_K, 3}, {nt_K, 1},
	{nt_L, 3}, {nt_L, 1},
	{nt_M, 2}, {nt_M, 2}, {nt_M, 1},
	{nt_N, 3}, {nt_N, 1}, {nt_N, 1}, {nt_N, 1} 
};

void Parser::diagnostic_for_reduce( unsigned state)
{
	if(state == 2)
	{
		printf("В строке %d ожидается что-либо из следующего: %s.\n",
	       scan->get_line_number(), "?, !||, ||, ^^"); 
	}
	else if( (state > 2 && state < 5) ||
			 (state > 34 && state < 38) ||
			 (state > 38 && state < 42) ||
			 (state > 42 && state < 45))
	{
		 printf("В строке %d ожидается что-либо из следующего: %s.\n",
	       scan->get_line_number(), "?, :, !||, ||, ^^, !&&, &&");	
	}
	else if( state == 5)
	{
		printf("В строке %d ожидается что-либо из следующего: %s.\n",
	       scan->get_line_number(), "?, :, !||, ||, ^^, !&&, &&, =, !=, <, >, <=, >=");
	}
	else if( state == 6 || (state > 44 && state < 51))
	{
		printf("В строке %d ожидается что-либо из следующего: %s.\n",
	       scan->get_line_number(), "?, :, !||, ||, ^^, !&&, &&, =, !=, <, >, <=, >=, +, -");
	}
	else if( (state > 6 && state < 9) || (state > 50 && state < 56))
	{
		 printf("В строке %d ожидается что-либо из следующего: %s.\n",
	       scan->get_line_number(), "?, :, !||, ||, ^^, !&&, &&, =, !=, <, >, <=, >=, +, -, *, /");	
	}
	else if( (state > 8 && state < 11) || (state > 14 && state < 18) || (state == 56))
	{
		 printf("В строке %d ожидается что-либо из следующего: %s.\n",
	       scan->get_line_number(), "?, :, !||, ||, ^^, !&&, &&, =, !=, <, >, <=, >=, +, -, *, /, **");	
	}
	else if(state == 58)
	{
		printf("В строке %d ожидается что-либо из следующего: %s.\n",
	       scan->get_line_number(), "!||, ||, ^^"); 
	}
		         
	ec->increment_number_of_errors();
	return;
}

const char* lexem_names_as_strings[] = {
	"NONE"  		 , "CONDITION" 		, "COLON"     , "NOR"     	,		"OR"		 ,
	"XOR" 			 , "NAND"	  		, "AND"	  	  , "NOT"	  	,		"EQ"		 ,
	"NEQ"			 , "LT"  	  		, "GT"	  	  ,	"LEQ"	  	,		"GEQ"		 ,
	"PLUS"  		 , "MINUS"	  		, "MULT"	  ,	"DIV"	  	,		"DEGREE"	 , 
	"OPENED_BRACKET" , "CLOSED_BRACKET" , "kw_ISTINA" ,	"kw_LOZH" 	,		"t_INT"		 ,
	"UNKNOWN"		 , "MAYBE_NOR"		, "MAYBE_OR"  , "MAYBE_XOR" ,		"MAYBE_NAND" ,
	"MAYBE_AND"
};

void Parser::parse(){
	Parser_stack_elem  initial_elem;
	initial_elem.state        = 0;
	initial_elem.is_undefined = 0;
	initial_elem.type         = 0;
	
	stack->push(initial_elem);
	
	for( ; ; ){
		//stack->print_stack();
		lc = scan->get_current_lexem();	
		printf("lc = %s\n", lexem_names_as_strings[lc.probably_code]);
		ai = get_action((stack->top()).state, lc.probably_code);	
		switch(ai.action){
			case act_REDUCE:
				reduce(ai.argument, ai.is_undefined);
				scan->back();
				break;
				
			case act_SHIFT:
				shift(ai.argument, ai.is_undefined);
				break;
				
			case act_OK:
				Intermediate_command command;
				command.op 	= op_STOP;
				gen->append(&command);
				gen->writeToFile();
				return;
				
			default:
				;
		}
	}
	return;
}

void Parser::shift(short shifted_state, short is_undef){
	
	if(is_undef){
		stack->print_stack();
		diagnostic_for_shift(shifted_state);
	}
	
	Parser_stack_elem    pushed_elem;
	
	pushed_elem.state        = shifted_state;
	pushed_elem.is_undefined = is_undef;
	pushed_elem.type		 = 0;
	
	stack->push(pushed_elem);
	return;
}

void Parser::reduce(short rule_for_reduce, short is_undef)
{
	size_t               length_of_rule;
	Parser_stack_elem    pushed_elem;
	Rule_info            ri;
	Intermediate_command command;
		    
    if(is_undef){
    	diagnostic_for_reduce((stack->top()).state);
    }
	
	ri = rules[rule_for_reduce];
	length_of_rule = ri.length;
	stack->get_elems(body, length_of_rule);
	stack->multi_pop(length_of_rule);
	
	pushed_elem.is_undefined = is_undef;
	pushed_elem.state        = 
		get_next_state(static_cast<Non_terminal>(ri.non_terminal), (stack->top()).state);

	switch(rule_for_reduce)
	{
		case S_IS_T: case T_IS_E: case E_IS_F: case F_IS_G: case G_IS_H: 
		case H_IS_K: case K_IS_L: case L_IS_M: case M_IS_N: case M_IS_PLUS_N:
		case N_IS_OB_S_CB:
			pushed_elem.type = body[0].type;
			stack->push(pushed_elem);
			return;	
			
		case S_IS_T_COND_T_COLON_T:
			command.op 		= op_CONDITION;
			break;
			
		case T_IS_T_NOR_E: case T_IS_T_OR_E: case T_IS_T_XOR_E:
			command.op 		= op_NOR + static_cast<Instruction_name>(rule_for_reduce - (int)T_IS_T_NOR_E);
			break;
			
		case E_IS_E_NAND_F: case E_IS_E_AND_F:
			command.op 		= op_NAND + static_cast<Instruction_name>(rule_for_reduce - (int)E_IS_E_NAND_F);
			break;
			
		case F_IS_NOT_F:
			command.op 		= op_NOT;
			break;
			
		case G_IS_G_EQ_H: case G_IS_G_NEQ_H: case G_IS_G_LT_H:	
		case G_IS_G_GT_H: case G_IS_G_LEQ_H: case G_IS_G_GEQ_H:
			command.op 		= op_EQ + static_cast<Instruction_name>(rule_for_reduce - (int)G_IS_G_EQ_H);
			break;
			
		case H_IS_H_PLUS_K: case H_IS_H_MINUS_K:
			command.op 		= op_ADD + static_cast<Instruction_name>(rule_for_reduce - (int)H_IS_H_PLUS_K);
			break;
			
		case K_IS_K_MULT_L: case K_IS_K_DIV_L:
			command.op 		= op_MULT + static_cast<Instruction_name>(rule_for_reduce - (int)K_IS_K_MULT_L);
			break;
			
		case L_IS_M_DEGREE_L:
			command.op 		= op_POWER;
			break;
		
		case M_IS_MINUS_N:
			command.op 		= op_CHANGE_SIGN;
			break;
				
		case N_IS_TRUE: 
			pushed_elem.type 		= LOGICAL_TYPE;
			command.op				= op_LOAD_TRUE;
			command.number_const	= 1;
			break;
		case N_IS_FALSE:
			pushed_elem.type 		= LOGICAL_TYPE;
			command.op				= op_LOAD_FALSE;
			command.number_const	= 0;
			break;
		
		case N_IS_INT:
			pushed_elem.type		= UNSIGN_INT_TYPE;
			command.op				= op_LOAD_INT_CONST;
			command.number_const	= lc.number;
			break; 
			
		default:
			return;
				
	}

	gen->append(&command);
		
	stack->push(pushed_elem);
		
	return;		
}
